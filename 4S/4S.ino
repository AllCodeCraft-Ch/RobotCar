#include "Arduino_LED_Matrix.h"

int B_L = 0;
int B_R = 10;


#define Int_wheel_R 2 //กำหนดขาอินพุตที่ต่อจากเซ็นเซอร์ Opto ที่ล้อขวา (ที่ขา INT 0)
#define Int_wheel_L 3 //กำหนดขาอินพุตที่ต่อจากเซ็นเซอร์ Opto ที่ล้อซ้าย (ที่ขา INT 1)
#define PI 3.1415926535897932384626433832795 //กำหนดค่าของ Pi
#define Wheel_Radiant 3.4925 // รัศมีของล้อ

ArduinoLEDMatrix matrix;

//ล้อขวา
int ENA=10; //กำหนดให้ขาที่ 10 เชื่อมต่อกับขา ENA ของ L298N
int IN1=9; //กำหนดให้ขาที่ 9 เชื่อมต่อกับขา IN1 ของ L298N
int IN2=8; //กำหนดให้ขาที่ 8 เชื่อมต่อกับขา IN2 ของ L298N
//ล้อซ้าย
int ENB=5; //กำหนดให้ขาที่ 5 เชื่อมต่อกับขา ENB ของ L298N
int IN3=7; //กำหนดให้ขาที่ 7 เชื่อมต่อกับขา IN3 ของ L298N
int IN4=6; //กำหนดให้ขาที่ 6 เชื่อมต่อกับขา IN4 ของ L298N

volatile unsigned int noClk_R = 0; //กำหนดตัวแปรที่ใช้นับจำนวน 1 พัลส์จาก Encoder Disk ที่ล้อขวา
volatile unsigned int noClk_L = 0; //กำหนดตัวแปรที่ใช้นับจำนวน 1 พัลส์จาก Encoder Disk ที่ล้อซ้าย
volatile unsigned int prev_time = 0;


float noSlots = 20.00; //จำนวนช่องว่างของ Encoder Disk บนจานล้อหมุน
float round_distance = 2*PI*Wheel_Radiant; //ระยะทางของล้อหุ่นยนต์ต่อการหมุน 1 รอบ (เส้นรอบวง) หน่วยเป็น ซม. ใช้สูตร 2xPixรัศมีของล้อ
float one_tick = round_distance/noSlots; //ค่าระยะทางการเดินทางของล้อจำนวน 1 พัลส์ที่นับได้จากขา IRQ
float length_wheelbase = 22.5; //ค่าความยาวของฐานล้อ หน่วยเป็นเซ็นติเมตร
float circumference = 2*PI*length_wheelbase; //ระยะทางการเคลื่อนที่ของหุ่นยนต์ในล้อซ้ายหรือล้อขวาในกรณีหมุนครบ 360 องศา Question 1
float TT_noPulse_IRQ = circumference/one_tick; //จำนวนพัลส์ที่นับได้ใน ISR ที่ล้อซ้ายหรือล้อขวาในกรณีที่หุ่นยนต์เลี้ยวครบ 360 องศา Question 2
float anglePerIRQ = 360/TT_noPulse_IRQ; //ค่าองศาที่เกิดขึ้นของการเลี้ยวต่อการนับจำนวนพัลส์ 1 พัลส์ใน ISR Question 3

float distance_R = 0; //ตัวแปรที่ใช้เก็บระยะทางการเดินทางของล้อขวาหน่วยเป็นเซ็นติเมตร
float distance_L = 0; //ตัวแปรที่ใช้เก็บระยะทางการเดินทางของล้อซ้ายหน่วยเป็นเซ็นติเมตร



void ISR_count_R(){ // นับจำนวนพัลส์ที่ผ่านช่องว่างของ Encoder Disk บนจานล้อหมุนที่ล้อขวา
  noClk_R = noClk_R + 1; //เพิ่มค่าจำนวนของตัวแปรที่ใช้นับ IRQ ที่ล้อขวาไป 1
}

void ISR_count_L(){ // นับจำนวนพัลส์ที่ผ่านช่องว่างของ Encoder Disk บนจานล้อหมุนที่ล้อซ้าย
  noClk_L = noClk_L + 1; //เพิ่มค่าจำนวนของตัวแปรที่ใช้นับ IRQ ที่ล้อซ้ายไป 1
}
//ฟังก์ชั่นนี้จะทำการแปลงระยะทางการเดินของหุ่นยนต์จากหน่วยเซ็นติเมตรเป็นจำนวนพัลส์ที่ต้องนับใน ISR สำหรับดักค่า IRQ ในล้อซ้ายและล้อขวา ใช้ในกรณีเดินหน้าและถอยหลัง
int CM_To_noClk(float IP_cm){
  float TT_noClk_B = IP_cm/one_tick;
  int TT_noClk = (int) TT_noClk_B;
  return TT_noClk;
}
//ฟังก์ชั่นนี้จะทำการแปลงความเร็วของหุ่นยนต์จากหน่วยเซ็นติเมตร/วินาทีเป็นค่า Duty Cycle ของ PWM เพื่อใช้ป้อนให้กับขา ENA และ ENB ของ L298N
int SP_To_PWM(float IP_sp){
  int TT_PWM = map(IP_sp,0,70,0,4095); //แม็พค่าความเร็วสูงสุดของหุ่นยนต์ ในที่นี้คือ 70 เซ็นติเมตรต่อวินาทีให้มีค่าระหว่าง 0-4095
  return TT_PWM;
}
//ฟังก์ชั่นนี้จะทำการแปลงค่าองศาการเลี้ยวของหุ่นยนต์ไปเป็นจำนวนพัลส์ที่ต้องนับใน ISR สำหรับดักค่า IRQ ในล้อซ้ายหรือล้อขวา ใช้ในกรณีเลี้ยวซ้ายและเลี้ยวขวา
int DGT_To_noClk(float IP_dg){
  float TT_noClk_D = IP_dg*(1/anglePerIRQ);
  int TT_noClk = (int) TT_noClk_D;
  return TT_noClk;
}
//ฟังก์ชั่นนี้จะทำการแปลงค่าองศาการหมุนของหุ่นยนต์ไปเป็นจำนวนพัลส์ที่ต้องนับใน ISR สำหรับดักค่า IRQ ในล้อซ้ายและล้อขวา ใช้ในกรณีหมุนซ้ายและหมุนขวา
int DGR_To_noClk(float IP_dgr){
  float TT_noClk_DR = IP_dgr*(1/(2*anglePerIRQ));
  int TT_noClk = (int) TT_noClk_DR;
  return TT_noClk;
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์เคลื่อนที่ไปด้านหน้าด้วยความเร็วคงที่ อินพุตจะมี 2 ค่าคือ ความเร็วของหุ่นยนต์มีหน่วยเป็นเซ็นติเมตรต่อวินาที และ ระยะทางที่ต้องการให้หุ่นยนต์เคลื่อนที่มีหน่วยเป็นเซ็นติเมตร
void forward(float CMpS_speed, float CM_distance){

  // showForwardFace();
  
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์เดินไปด้านหน้า
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าระยะทางที่ต้องการให้หุ่นยนต์เคลื่อนที่เป็นจำนวนพัลส์ที่ต้องใช้นับใน ISR
  int Pulse_distance = CM_To_noClk(CM_distance);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_distance > noClk_R && Pulse_distance > noClk_L){
    //ในกรณีล้อขวา
    if(Pulse_distance > noClk_R){ 
      analogWrite(ENA, PWM_speed - B_R); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
    }
    else{
      analogWrite(ENA, 0); //ถ้าถึงระยะทางที่กำหนดให้ล้อขวาหยุด
    }
    //ในกรณีล้อซ้าย
    if(Pulse_distance > noClk_L){
      analogWrite(ENB, PWM_speed - B_L); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{
      analogWrite(ENB, 0); //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายหยุด
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 1650){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // showStopFace();
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;

  
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์เคลื่อนที่ไปด้านหลังด้วยความเร็วคงที่ อินพุตจะมี 2 ค่าคือ ความเร็วของหุ่นยนต์มีหน่วยเป็นเซ็นติเมตรต่อวินาที และ ระยะทางที่ต้องการให้หุ่นยนต์เคลื่อนที่มีหน่วยเป็นเซ็นติเมตร
void backward(float CMpS_speed, float CM_distance){
  
  // showBackwardFace();

  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์เดินถอยหลัง
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าระยะทางที่ต้องการให้หุ่นยนต์เคลื่อนที่เป็นจำนวนพัลส์ที่ต้องใช้นับใน ISR
  int Pulse_distance = CM_To_noClk(CM_distance);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_distance > noClk_R && Pulse_distance > noClk_L){
    //ในกรณีล้อขวา
    if(Pulse_distance > noClk_R){ 
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
    }
    else{
      analogWrite(ENA, 0); //ถ้าถึงระยะทางที่กำหนดให้ล้อขวาหยุด
    }
    //ในกรณีล้อซ้าย
    if(Pulse_distance > noClk_L){
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{
      analogWrite(ENB, 0); //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายหยุด
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 1650){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // showStopFace();
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;

  
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการเลี้ยวขวาแบบเดินหน้า อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการเลี้ยวมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการเลี้ยวมีหน่วยเป็นองศา
void turn_right_forward(float CMpS_speed, float DG_turn){
  
  // showTurnRightFace();

  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการเลี้ยวขวา (ใช้เหมือนกับกรณีเดินหน้าเพียงแต่ว่ากำหนดความเร็วให้เพียงล้อซ้ายและหยุดล้อขวา)
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการเลี้ยวให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อซ้าย
  int Pulse_angle = DGT_To_noClk(DG_turn);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อซ้ายว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_L){
    //ในกรณีล้อซ้าย
    if(Pulse_angle > noClk_L){
      analogWrite(ENA, 0); //ล้อขวาหยุดหมุน
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 1650){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // showStopFace();
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;

}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการเลี้ยวขวาแบบถอยหลัง อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการเลี้ยวมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการเลี้ยวมีหน่วยเป็นองศา
void turn_right_backward(float CMpS_speed, float DG_turn){
  
  // showTurnRightFace();
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการเลี้ยวขวา (ใช้เหมือนกับกรณีเดินหน้าเพียงแต่ว่ากำหนดความเร็วให้เพียงล้อซ้ายและหยุดล้อขวา)
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการเลี้ยวให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อซ้าย
  int Pulse_angle = DGT_To_noClk(DG_turn);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อซ้ายว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_L){
    //ในกรณีล้อซ้าย
    if(Pulse_angle > noClk_L){
      analogWrite(ENA, 0); //ล้อขวาหยุดหมุน
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 1650){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // showStopFace();
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;

  
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการเลี้ยวซ้ายแบบเดินหน้า อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการเลี้ยวมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการเลี้ยวมีหน่วยเป็นองศา
void turn_left_forward(float CMpS_speed, float DG_turn){
  
  // showTurnLeftFace();
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการเลี้ยวซ้าย (ใช้เหมือนกับกรณีเดินหน้าเพียงแต่ว่ากำหนดความเร็วให้เพียงล้อขวาและหยุดล้อซ้าย)
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการเลี้ยวให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อขวา
  int Pulse_angle = DGT_To_noClk(DG_turn);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อขวาว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_R){
    //ในกรณีล้อขวา
    if(Pulse_angle > noClk_R){
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
      analogWrite(ENB, 0); //ล้อซ้ายหยุดหมุน
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 1650){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // showStopFace();
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;

  
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการเลี้ยวซ้ายแบบถอยหลัง อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการเลี้ยวมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการเลี้ยวมีหน่วยเป็นองศา
void turn_left_backward(float CMpS_speed, float DG_turn){
  
  // showTurnLeftFace();
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการเลี้ยวซ้าย (ใช้เหมือนกับกรณีเดินหน้าเพียงแต่ว่ากำหนดความเร็วให้เพียงล้อขวาและหยุดล้อซ้าย)
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการเลี้ยวให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อขวา
  int Pulse_angle = DGT_To_noClk(DG_turn);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อขวาว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_R){
    //ในกรณีล้อขวา
    if(Pulse_angle > noClk_R){
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
      analogWrite(ENB, 0); //ล้อซ้าย
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 1650){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // showStopFace();
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;

  
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการหมุนขวา อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการหมุนมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการหมุนมีหน่วยเป็นองศา
void spin_right(float CMpS_speed, float DG_spin){
  
  // showSpinRightFace();
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการหมุนขวา (ล้อซ้ายเดินหน้าล้อขวาถอยหลัง)
  digitalWrite(IN1, HIGH); //ล้อซ้าย
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW); //ล้อขวา
  digitalWrite(IN4, HIGH);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการหมุนให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อขวา
  int Pulse_angle = DGR_To_noClk(DG_spin);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อซ้ายว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_L){
    //ในกรณีล้อซ้ายและขวา
    if(Pulse_angle > noClk_L){
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 1650){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // showStopFace();
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;

  
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์ทำการหมุนซ้าย อินพุตมีอยู่ 2 ค่าคือ ค่าความเร็วของการหมุนมีหน่วยเป็นเซ็นติเมตรต่อวินาทีและองศาการหมุนมีหน่วยเป็นองศา
void spin_left(float CMpS_speed, float DG_spin){
  
  // showSpinLeftFace();
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์ทำการหมุนซ้าย (ล้อซ้ายถอยหลังล้อขวาเดินหน้า)
  digitalWrite(IN1, LOW); //ล้อซ้าย
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH); //ล้อขวา
  digitalWrite(IN4, LOW);
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;
  //ทำการแปลงค่าความเร็วของหุ่นยนต์เป็น PWM
  int PWM_speed = SP_To_PWM(CMpS_speed);
  //ทำการแปลงค่าองศาการหมุนให้เป็นค่าจำนวนพัลส์ที่จะต้องใช้นับในล้อขวา
  int Pulse_angle = DGR_To_noClk(DG_spin);
  //ทำการดักค่าจำนวนพัลส์ใน IRQ ที่ล้อขวาว่าครบตามกำหนดระยะทางแล้วหรือยังถ้าครบตามจำนวนที่กำหนดแล้วให้หุ่นยนต์หยุดการเคลื่อนที่
  while (Pulse_angle > noClk_R){
    //ในกรณีล้อซ้ายและขวา
    if(Pulse_angle > noClk_R){
      analogWrite(ENA, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อขวา
      analogWrite(ENB, PWM_speed); //ถ้ายังไม่ถึงระยะทางที่กำหนดให้ใส่ PWM ไปที่ล้อซ้าย
    }
    else{ //ถ้าถึงระยะทางที่กำหนดให้ล้อซ้ายและขวาหยุด
      analogWrite(ENA, 0);
      analogWrite(ENB, 0); 
    }
  }
  //ใช้สำหรับดักค่า PWM ในกรณีที่ Duty Cycle ต่ำกว่าที่ L298N จะสามารถเอาไปขับมอเตอร์ให้หมุนได้ ป้องกันความเสียหายของมอเตอร์ในช่วง 0-2050 (ในที่นี้ความเร็วในการสั่งงานของมอเตอร์อยู่ที่ 0 - 4095)
  if (PWM_speed < 1650){
    PWM_speed = 0;
  }
  //ทำการหยุดการเคลื่อนที่ของหุ่นยนต์เมื่อทำภารกิจเดินหน้าสำเร็จตามระยะทางที่กำหนด
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // showStopFace();
  //ทำการล้างค่าการนับใน IRQ ทั้งล้อซ้ายและล้อขวา
  noClk_R = 0;
  noClk_L = 0;

  
}

//ฟังก์ชั่นนี้จะทำให้หุ่นยนต์หยุดเดิน
void stop(){
  // showStopFace();
  
  //กำหนดพารามิเตอร์ที่ L298N เพื่อให้หุ่นยนต์เพื่อให้หุ่นยนต์หยุดเดิน
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);

  
}

void setup() {
  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  //กำหนดค่าในการทำ Hardware IRQ
  attachInterrupt(digitalPinToInterrupt(Int_wheel_R), ISR_count_R, RISING); // กำหนดพารามิเตอร์สำหรับ HW IRQ ให้กับล้อขวาเพื่อนับจำนวนพัลส์ที่ขอบขาขึ้น
  attachInterrupt(digitalPinToInterrupt(Int_wheel_L), ISR_count_L, RISING); // กำหนดพารามิเตอร์สำหรับ HW IRQ ให้กับล้อซ้ายเพื่อนับจำนวนพัลส์ที่ขอบขาขึ้น
  //เปลี่ยนความละเอียดของ PWM จาก 0 - 255 เป็น 0 - 4095
  analogWriteResolution(12);

  // matrix.begin();
  // matrix.play(true);
 
}

void loop() {
  forward(60, 395); //เคลื่อนที่ไปข้างหน้าด้วยความเร็ว 60 ซม/วินาที เป็นระยะทาง 100 ซม
  delay(500);
  turn_right_forward(50, 285);
  delay(500);
  //turn_right_backward(70, 30);
  // turn_right_forward(70, 70);

  // turn_right_forward(70, 270); //ทำการเลี้ยวซ้าย (ไปข้างหน้า) ด้วยความเร็ว 70 ซม/วินาที (สูงสุด) โดยทำการเลี้ยว 180 องศา
  // turn_right_forward(70, 180); //ทำการเลี้ยวซ้าย (ไปข้างหน้า) ด้วยความเร็ว 70 ซม/วินาที (สูงสุด) โดยทำการเลี้ยว 180 องศา
  // delay(500);
  forward(60, 500); //เคลื่อนที่ไปข้างหน้าด้วยความเร็ว 60 ซม/วินาที เป็นระยะทาง 100 ซม
  delay(500);
  turn_left_forward(50, 360);
  turn_left_forward(50, 30);
  delay(500);
  forward(60, 380); //เคลื่อนที่ไปข้างหน้าด้วยความเร็ว 60 ซม/วินาที เป็นระยะทาง 100 ซม
  delay(500);
  turn_right_forward(50, 280);
  delay(500);
  //turn_right_forward(70, 195);
  forward(60, 480); //เคลื่อนที่ไปข้างหน้าด้วยความเร็ว 60 ซม/วินาที เป็นระยะทาง 100 ซม
  stop();
  delay(5000);
 
}

